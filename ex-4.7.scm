; (print ((lambda (x)
;           ((lambda (y)
;              ((lambda (z)
;                 (* x z))
;               (+ x y 5)))
;            (+ x 2)))
;         3))
;
; (let ((x 3))
;   (let ((y (+ x 2)))
;     (let ((z (+ x y 5)))
;       (* x z))))

; (let* ((var1 exp1)
;        (var2 exp2)
;        ...
;        (varN expN))
;   body)
;
; (let ((var1 exp1))
;   (let ((var2 exp2))
;     ...
;       (let ((varN expN))
;         body)))

(define (let*? exp)
  (tagged-list? exp 'let*))

(define let*-bindings let-bindings)
(define let*-body let-body)

(define (make-let bindings body)
  (cons 'let
        (cons bindings body)))

(define (let*->nested-lets exp)
  (define (go bindings)
    (if (null? bindings)
      (make-begin (let-body exp))
      (let ((first (car bindings))
            (rest (cdr bindings)))
        (make-let (list first)
                  (list (go rest))))))
  (go (let-bindings exp)))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) (eval (let->combination exp) env))
        ((let*? exp) (eval (let*->nested-lets exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
          (error "Unknown expression type -- EVAL" exp))))
