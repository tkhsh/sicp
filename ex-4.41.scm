(define (multiple-dwelling)
  (define test '((1 2 3) (4 5 6) (7 8 9)))
  (define (distinct? items)
    (cond ((null? items) #t)
          ((null? (cdr items)) #t)
          ((member (car items) (cdr items)) #f)
          (else (distinct? (cdr items)))))

  (define (make-combinations sets combination)
    (if (null? sets)
      (list (reverse combination))
      (append-map (lambda (e)
                    (make-combinations (cdr sets)
                                       (cons e combination)))
                  (car sets))))

  (let ((baker    (list 1 2 3 4 5))
        (cooper   (list 1 2 3 4 5))
        (fletcher (list 1 2 3 4 5))
        (miller   (list 1 2 3 4 5))
        (smith    (list 1 2 3 4 5))
        (get-baker    car)
        (get-cooper   cadr)
        (get-fletcher caddr)
        (get-miller   cadddr)
        (get-smith    (lambda (x) (cadddr (cdr x)))))
    (filter (lambda (comb)
              (and
                (not (= (get-baker comb) 5))
                (not (= (get-cooper comb) 1))
                (not (= (get-fletcher comb) 5))
                (not (= (get-fletcher comb) 1))
                (> (get-miller comb) (get-cooper comb))
                (not (= (abs (- (get-smith comb) (get-fletcher comb))) 1))
                (not (= (abs (- (get-fletcher comb) (get-cooper comb))) 1))
                (distinct? comb)))
            (make-combinations (list baker cooper fletcher miller smith) '())))
  )
(print (multiple-dwelling))
